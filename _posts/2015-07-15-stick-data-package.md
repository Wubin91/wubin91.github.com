---
layout: post
category: Socket编程
title: Socket粘包现象
tagline: by wubin
tags: [Socket, TCP]
---

##粘包现象产生的原因：

* 利用长连接发送数据，如TCP，以流的方式传输数据，无明显消息边界
* 发送端需要数据包拷贝到缓冲区满了，才将其发送出去，造成在发送端缓冲区粘包
* 接收方等接收缓冲区满了，才将数据发送到应用层进行处理，造成在接收端缓冲区粘包

<!--more-->

##解决办法：

* 对于发送端缓冲区粘包，可通过在发送端强制实行PUSH指令，一旦发送端需要发送一个消息，那么就无需等发送缓冲区满才发送，但是这样关闭了原本TCP的优化算法，造成开销太大，降低网络发送速率，影响应用的网络性能，一般不建议使用
* 对于接收端缓冲区粘包，则可以优化程序设计，精简接收进程工作量，提高接收进程的优先级，使其及时接收数据，从而在一定程度上降低了粘包的可能性，但无法完全避免，因为当发送端发送数据的频率很高时，或由于网络突发状况，使数据包在某个时间达到接收端很快，接收端还是有可能来不及接收，从而导致粘包
* 第三种方法是由接收端控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。但是这样的话，应用程序的效率很低，对实时性要求很高的场合并不适用
* 可以在每个包的头部加一些字段，记录这个包的数据部分的长度，这样可以确保接收端无误

##发包收包过程

以太网的MTU为1500，超过这个值，TCP会为IP数据报设置偏移量进行分片传输，目前一般在应用层设置8k字节的缓冲区，即我们平时使用的socket发送缓冲区和接收缓冲区大小。缓冲区大小可以通过SetSockOpt改变。对于UDP，缓冲区大小一般为1024~10k。无论发多大的数据包，IP层和链路层都会把大包进行分片发送，局域网通常为1500字节，广域网一般为几十个字节。对于UDP，只要其中有一个分片丢失或错误，那么接收端的IP层将把整个发送包丢弃，形成丢包。所以UDP的数据包尽可能不要太大，但考虑到效率问题，也不能太小；对于TCP，作为流，发包是不会整包到达的，而是源源不断地到，接收方必须组包。而UDP作为消息或数据报，一定是整包到达接收方。这里说的整包到达接收方是指到达接收端socket接收缓冲区的是一个完整包，而当中有可能是通过多个分片传输过来再组片的，但是这是链路层和IP层负责的事情，socket在传输层，无需考虑这些细节。
